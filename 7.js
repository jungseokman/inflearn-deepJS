// 클로저는 쉽게 말해서 함수와 외부 변수와의 관계를 말한다.
// 클로저 문제 -> 스코프, 비동기, var(쓰레기)
// 클로저가 문제다 X
// 클로저를 사용해서 해결하는 문제
// for문(반복문)과 비동기를 함께 사용하면 종종 발생

// 문제 : var과 for과 비동기의 환상의 콜라보
function a() {
  for (var i = 0; i < 5; i++) {
    // 백그라운드가 처리되기전에 콜스택에서 i가 5가 된다.
    setTimeout(() => {
      console.log(i); // var는 블록을 따르지 않고 부모함수를 따른다.
    }, i * 1000); // 0, 1000, 2000, 3000, 4000
  }
}
a(); // 5, 5, 5, 5, 5 로 나온다. (i가 마지막 i값인 5를 바라본다.)
// function a 스코프는 1개고, for문의 스코프는 5개
// a스코프에서 i는 0 -> 5가 되는거고, for문의 스코프 5개에서 i는 각각 0,1,2,3,4

// 해결법 : var 유지 -> 즉시질행함수로 클로저 생성
function a() {
  for (var i = 0; i < 5; i++) {
    (function (j) {
      setTimeout(() => {
        console.log(j); // 값이 5인 i가 아니라 매개변수로 받은 j를 바라보기 떄문
      }, i * 1000);
    })(i);
  }
}
a(); // 0, 1, 2, 3, 4 로 출력됨
// 즉시실행함수를 만들어서 for문의 스코프를 바라보게 함

// 해결법 : var -> let으로 변경
function a() {
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      console.log(i);
    }, i * 1000);
  }
}
a(); // 0, 1, 2, 3, 4 로 출력됨
// let은 for문의 스코프를 바라본다.
